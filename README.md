# 정렬 알고리즘 직접 구현하기

## 퀵 정렬

분할 정복 알고리즘의 하나.  
기준이 되는 `pivot`을 임의로 뽑아 `pivot`보다 작으면 왼쪽에, 크면 오른쪽에 위치시킨다.
쪼개진 왼쪽, 오른쪽에 대해서도 임의로 `pivot`을 뽑아 같은 방법으로 정렬한다. 이를 반복

시간 복잡도 : O(NlogN)

### 구현 방식

1. **quickSort 함수**  
   `pivot`보다 작은 값들을 가지는 배열 `before`와 크거나 같은 값들을 가지는 배열 `after`을 만들었다.

2. **quickSortInPlace 함수**  
   `before`, `after` 배열을 추가하지 않고, 주어진 배열에서 위치를 바꾸는 방식으로 구현했다.

   2-1. 맨 앞의 값을 pivot으로 한다. `low`는 인덱스 1을 가리키고 `high`는 마지막 인덱스를 가리킨다.  
   2-2. `array[low]`의 값이 `pivot`보다 큰 값이 나올 때까지 low + 1 한다.  
   2-3. `array[high]`의 값이 `pivot`보다 작은 값이 나올 때까지 high - 1 한다.  
   2-4. `array[low]`와 `array[high]`의 값을 바꾼다. low가 high를 넘기 전까지 반복  
   2-5. `low > high`가 되면 반복을 멈추고, `array[start]`와 `array[high]`의 위치를 바꾼다. 이로써 pivot값을 기준으로 앞에는 작은 값들이 뒤에는 크거나 같은 값들이 위치하게 된다. pivot 앞과 뒤 배열을 기준으로 위 과정을 반복한다.

## 병합 정렬

분할 정복 알고리즘의 하나.  
배열을 비슷한 크기로 쪼개고 쪼개진 부분을 정렬하며 합쳐 나가는 방식. 합치는 과정에서 정렬이 이뤄진다.

### 구현 방식

비슷한 크기로 배열을 나눈다. 크기가 1이 될 때까지 쪼갠다. 이후 두 배열을 합친다.

합치는 과정  
1-1 `i`, `j`는 각각 두 배열(`part1`, `part2`)의 인덱스를 가리킨다. (초기값 0)  
1-2 `sortedArray`은 두 배열을 합친 새로운 배열이다.  
1-3 `part1[i]`와 `part2[j]`의 값을 비교해 작은 값을 `sortedArray`에 넣고 인덱스를 +1한다.  
1-4 `i`나 `j`가 배열의 마지막 값을 가리킬 때까지 위 과정(1-3)을 반복  
1-5 아직 남은 값이 남은 배열을 `sortedArray`에 이어 붙인다.

## To do

- [x] 병합 정렬
- [ ] 힙 정렬
- [ ] javascript sort함수는 어떤 알고리즘을 사용할까?
- [ ] javascript sort처럼 동작하는 함수 만들어보기
  - 지금 작성한 방식은 배열을 입력으로 받고 오름차순으로만 정렬되는데, 기준이 되는 값을 sort할 때 정할 수 있고 오름차순, 내림차순도 정할 수 있도록...!
